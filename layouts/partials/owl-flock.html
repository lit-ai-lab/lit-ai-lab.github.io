<!-- Thought Flow Squares Background Animation -->
<div id="thought-flow-container" class="absolute inset-0 w-full h-full overflow-hidden pointer-events-none z-0">
    <!-- Custom cursor -->
    <div id="custom-cursor" class="fixed w-5 h-5 pointer-events-none z-50 hidden"
        style="background: radial-gradient(circle, rgba(102,126,234,0.8) 0%, rgba(118,75,162,0.3) 70%, transparent 100%); border-radius: 50%; transition: transform 0.1s ease;">
    </div>

    <!-- Fallback for reduced motion preference -->
    <div id="squares-fallback" class="hidden absolute inset-0">
        <div
            class="w-8 h-8 opacity-20 absolute top-1/4 right-1/4 bg-gradient-to-br from-purple-400 to-pink-400 rounded">
        </div>
    </div>
</div>

<!-- Check for reduced motion preference -->
<style>
    @media (prefers-reduced-motion: reduce) {
        #thought-flow-container .square {
            display: none !important;
        }

        #squares-fallback {
            display: block !important;
        }
    }

    /* Hide default cursor in container */
    #thought-flow-container {
        cursor: none;
    }

    .square {
        position: absolute;
        border-radius: 4px;
        transition: all 0.3s ease;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
    }

    .ripple {
        position: absolute;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        pointer-events: none;
        animation: rippleExpand 1.5s ease-out forwards;
    }

    @keyframes rippleExpand {
        0% {
            width: 0;
            height: 0;
            opacity: 0.8;
        }

        100% {
            width: 400px;
            height: 400px;
            opacity: 0;
        }
    }
</style>

<script>
    (function () {
        'use strict';

        // Prevent duplicate execution
        if (window.thoughtFlowActive) {
            return;
        }
        window.thoughtFlowActive = true;

        console.log("✨ Starting Thought Flow Squares...");

        class ThoughtSquare {
            constructor(x, y, size, color, speed = 1, generation = 0) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.originalSize = size;
                this.color = color;
                this.speed = speed;
                this.generation = generation;
                this.vx = -speed * (0.7 + Math.random() * 0.3);
                this.vy = speed * (0.7 + Math.random() * 0.3);
                this.life = 1.0;
                this.maxLife = generation === 0 ? Infinity : 5000 + Math.random() * 3000;
                this.birthTime = Date.now();
                this.element = this.createElement();
                this.rippleInfluence = { x: 0, y: 0, strength: 0 };
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'square';
                el.style.width = this.size + 'px';
                el.style.height = this.size + 'px';
                el.style.background = this.color;
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                el.style.zIndex = Math.floor(100 - this.generation * 10);
                container.appendChild(el);
                return el;
            }

            update(mouseX, mouseY) {
                // Age and lifecycle
                const age = Date.now() - this.birthTime;
                if (this.maxLife !== Infinity) {
                    this.life = Math.max(0, 1 - age / this.maxLife);
                    if (this.life <= 0) return false;
                }

                // Base movement
                this.x += this.vx;
                this.y += this.vy;

                // Magnetic attraction to cursor
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 150 && dist > 0) {
                    const magnetStrength = (150 - dist) / 150 * 0.15;
                    const pullX = (dx / dist) * magnetStrength;
                    const pullY = (dy / dist) * magnetStrength;

                    this.vx += pullX * 0.05;
                    this.vy += pullY * 0.05;

                    if (dist < 60) {
                        const repelStrength = (60 - dist) / 60 * 0.1;
                        this.vx -= pullX * repelStrength;
                        this.vy -= pullY * repelStrength;
                    }
                }

                // Friction
                this.vx *= 0.95;
                this.vy *= 0.95;

                // Force diagonal movement
                this.x -= 0.8;
                this.y += 0.8;

                // Gentle oscillation
                this.y += Math.sin(Date.now() * 0.001 + this.x * 0.01) * 0.2;

                // Update visual properties
                const currentSize = this.originalSize * (0.7 + 0.3 * this.life);
                const opacity = this.generation === 0 ? 0.9 : this.life * 0.7;
                const magnetInfluence = dist < 150 ? (150 - dist) / 150 : 0;

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.width = currentSize + 'px';
                this.element.style.height = currentSize + 'px';
                this.element.style.opacity = opacity;
                this.element.style.transform = `rotate(${this.x * 0.5}deg) scale(${1 + magnetInfluence * 0.4})`;

                // Remove if off screen
                if (this.x < -100 || this.y > window.innerHeight + 100) return false;

                return true;
            }

            shouldBranch(mouseX, mouseY) {
                if (this.generation >= 2) return false;

                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                return dist < 80 && Math.random() < 0.02 && this.size > 15;
            }

            branch() {
                const branches = [];
                const numBranches = 1 + Math.floor(Math.random() * 2);

                for (let i = 0; i < numBranches; i++) {
                    const angle = (Math.PI * 2 * i / numBranches) + (Math.random() - 0.5) * 0.5;
                    const speed = this.speed * (0.9 + Math.random() * 0.2);
                    const newSize = this.size * 0.4;
                    const colors = [
                        'linear-gradient(45deg, #ff6b6b, #ee5a24)',
                        'linear-gradient(45deg, #4834d4, #686de0)',
                        'linear-gradient(45deg, #00d2d3, #54a0ff)',
                        'linear-gradient(45deg, #5f27cd, #00d2d3)',
                        'linear-gradient(45deg, #ff9ff3, #f368e0)'
                    ];

                    const branch = new ThoughtSquare(
                        this.x + Math.cos(angle) * 15,
                        this.y + Math.sin(angle) * 15,
                        newSize,
                        colors[Math.floor(Math.random() * colors.length)],
                        speed,
                        this.generation + 1
                    );

                    branch.vx = this.vx + Math.cos(angle) * 0.3;
                    branch.vy = this.vy + Math.sin(angle) * 0.3;

                    branches.push(branch);
                }

                return branches;
            }

            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 200;
                this.strength = 1;
                this.life = 1;
                this.element = this.createElement();
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'ripple';
                el.style.left = (this.x - 200) + 'px';
                el.style.top = (this.y - 200) + 'px';
                container.appendChild(el);
                return el;
            }

            update() {
                this.radius += 3;
                this.life = Math.max(0, 1 - this.radius / this.maxRadius);
                this.strength = this.life;

                if (this.life <= 0) {
                    this.destroy();
                    return false;
                }
                return true;
            }

            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }

        let container;
        let cursor;
        const squares = [];
        const ripples = [];
        let mouseX = 0, mouseY = 0;
        let animationId;

        function initializeAnimation() {
            container = document.getElementById('thought-flow-container');
            cursor = document.getElementById('custom-cursor');

            if (!container) {
                console.error("❌ Container not found, retrying...");
                setTimeout(initializeAnimation, 100);
                return;
            }

            console.log("✨ Container found, starting animation");

            // Mouse tracking
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                if (cursor) {
                    cursor.style.left = (mouseX - 10) + 'px';
                    cursor.style.top = (mouseY - 10) + 'px';
                    cursor.classList.remove('hidden');
                }
            });

            // Click for ripples
            document.addEventListener('click', (e) => {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        ripples.push(new Ripple(e.clientX + (Math.random() - 0.5) * 50, e.clientY + (Math.random() - 0.5) * 50));
                    }, i * 100);
                }
            });

            // Start animation
            animate();

            // Initial squares
            for (let i = 0; i < 3; i++) {
                setTimeout(() => spawnSquare(), i * 800);
            }
        }

        function spawnSquare() {
            const colors = [
                'linear-gradient(45deg, #667eea, #764ba2)',
                'linear-gradient(45deg, #f093fb, #f5576c)',
                'linear-gradient(45deg, #4facfe, #00f2fe)',
                'linear-gradient(45deg, #43e97b, #38f9d7)',
                'linear-gradient(45deg, #fa709a, #fee140)'
            ];

            const size = 25 + Math.random() * 25;
            const x = Math.random() * (window.innerWidth - size);
            const speed = 0.3 + Math.random() * 0.4;

            squares.push(new ThoughtSquare(
                x,
                -50,
                size,
                colors[Math.floor(Math.random() * colors.length)],
                speed,
                0
            ));
        }

        function animate() {
            if (!container) return;

            // Update squares
            for (let i = squares.length - 1; i >= 0; i--) {
                const square = squares[i];

                // Check for branching
                if (square.shouldBranch(mouseX, mouseY)) {
                    const branches = square.branch();
                    squares.push(...branches);
                }

                // Update square
                if (!square.update(mouseX, mouseY)) {
                    square.destroy();
                    squares.splice(i, 1);
                }
            }

            // Spawn new squares
            if (Math.random() < 0.015) {
                spawnSquare();
            }

            animationId = requestAnimationFrame(animate);
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeAnimation);
        } else {
            setTimeout(initializeAnimation, 100);
        }

        console.log("✨ Thought Flow Squares script loaded");
    })();
</script>