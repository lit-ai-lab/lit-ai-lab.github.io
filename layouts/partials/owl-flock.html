<!-- Thought Flow Squares Background Animation -->
<div id="thought-flow-container" class="absolute inset-0 w-full h-full overflow-hidden pointer-events-none z-0">
    <!-- Custom cursor -->
    <div id="custom-cursor" class="fixed w-5 h-5 pointer-events-none z-50 hidden"
        style="background: radial-gradient(circle, rgba(102,126,234,0.8) 0%, rgba(118,75,162,0.3) 70%, transparent 100%); border-radius: 50%; transition: transform 0.1s ease;">
    </div>

    <!-- Fallback for reduced motion preference -->
    <div id="squares-fallback" class="hidden absolute inset-0">
        <div
            class="w-8 h-8 opacity-20 absolute top-1/4 right-1/4 bg-gradient-to-br from-purple-400 to-pink-400 rounded">
        </div>
    </div>
</div>

<!-- Check for reduced motion preference -->
<style>
    @media (prefers-reduced-motion: reduce) {
        #thought-flow-container .square {
            display: none !important;
        }

        #squares-fallback {
            display: block !important;
        }
    }

    /* Hide default cursor in container */
    #thought-flow-container {
        cursor: none;
    }

    .square {
        position: absolute;
        border-radius: 4px;
        transition: all 0.3s ease;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
    }

    .ripple {
        position: absolute;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        pointer-events: none;
        animation: rippleExpand 1.5s ease-out forwards;
    }

    @keyframes rippleExpand {
        0% {
            width: 0;
            height: 0;
            opacity: 0.8;
        }

        100% {
            width: 400px;
            height: 400px;
            opacity: 0;
        }
    }
</style>

<script>
    (function () {
        'use strict';

        // Prevent duplicate execution
        if (window.thoughtFlowActive) {
            return;
        }
        window.thoughtFlowActive = true;

        console.log("✨ Starting Thought Flow Squares...");

        class ThoughtSquare {
            constructor(x, y, size, color, speed = 1, generation = 0) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.originalSize = size;
                this.color = color;
                this.originalColor = color; // Store original color
                this.speed = speed;
                this.generation = generation;
                this.vx = -speed * (0.8 + Math.random() * 0.4); // Move left (negative)
                this.vy = (Math.random() - 0.5) * 0.3; // Slight vertical wobble
                this.life = 1.0;
                this.maxLife = generation === 0 ? Infinity : 5000 + Math.random() * 3000;
                this.birthTime = Date.now();
                this.element = this.createElement();
                this.rippleInfluence = { x: 0, y: 0, strength: 0 };
                this.avoidanceForce = { x: 0, y: 0 };
                this.targetY = y; // Target Y position for formation
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'square';
                el.style.width = this.size + 'px';
                el.style.height = this.size + 'px';
                el.style.background = this.color;
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                el.style.zIndex = Math.floor(200 + this.generation * 10 + Math.random() * 50); // Higher z-index, new squares on top
                container.appendChild(el);
                return el;
            }

            update(mouseX, mouseY) {
                // Age and lifecycle
                const age = Date.now() - this.birthTime;
                if (this.maxLife !== Infinity) {
                    this.life = Math.max(0, 1 - age / this.maxLife);
                    if (this.life <= 0) return false;
                }

                // Base movement (right to left like ducklings)
                this.x += this.vx;
                this.y += this.vy;

                // Steady left movement
                this.x -= 1.2; // Main left movement

                // Formation keeping - return to target Y position
                const yDiff = this.targetY - this.y;
                this.vy += yDiff * 0.02; // Gentle return to formation

                // Apply friction to prevent wild movements
                this.vy *= 0.95;

                // Mouse avoidance behavior
                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Only respond to mouse if square is within reasonable bounds
                const padding = 100;
                const isWithinBounds = this.x > -padding && 
                                       this.x < window.innerWidth + padding && 
                                       this.y > -padding && 
                                       this.y < window.innerHeight + padding;
                
                let avoidanceStrength = 0;
                if (dist < 200 && dist > 0 && isWithinBounds) {
                    // Avoidance force - push away from mouse
                    avoidanceStrength = (200 - dist) / 200;
                    const avoidX = (dx / dist) * avoidanceStrength * 3; // Push away from mouse
                    const avoidY = (dy / dist) * avoidanceStrength * 2;
                    
                    this.vx += avoidX * 0.1;
                    this.vy += avoidY * 0.15;
                    
                    // Change color when avoiding - cycle through different colors
                    const avoidColors = [
                        'linear-gradient(45deg, #ff6b6b, #ee5a24)', // Red
                        'linear-gradient(45deg, #feca57, #ff6b6b)', // Orange  
                        'linear-gradient(45deg, #48dbfb, #0abde3)', // Blue
                        'linear-gradient(45deg, #1dd1a1, #10ac84)', // Green
                        'linear-gradient(45deg, #a55eea, #8742d8)'  // Purple
                    ];
                    const colorIndex = Math.floor((Date.now() * 0.005) % avoidColors.length);
                    this.color = avoidColors[colorIndex];
                } else {
                    // Return to original color when not avoiding
                    this.color = this.originalColor;
                }

                // Gentle bobbing motion like ducklings
                this.y += Math.sin(Date.now() * 0.002 + this.x * 0.01) * 0.3;

                // Update visual properties
                const currentSize = this.originalSize * (0.8 + 0.2 * this.life);
                const opacity = this.generation === 0 ? 0.9 : this.life * 0.7;
                
                // Rotation based on avoidance (more rotation when avoiding)
                const rotationSpeed = 0.05 + avoidanceStrength * 0.3;
                const rotation = Date.now() * rotationSpeed * 0.001;
                
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.width = currentSize + 'px';
                this.element.style.height = currentSize + 'px';
                this.element.style.opacity = opacity;
                this.element.style.background = this.color;
                this.element.style.transform = `rotate(${rotation}deg) scale(${1 + avoidanceStrength * 0.2})`;

                // Remove if off screen - all boundaries with padding
                const footerHeight = 200;
                if (this.x < -padding || 
                    this.x > window.innerWidth + padding || 
                    this.y > window.innerHeight - footerHeight ||
                    this.y < -padding) {
                    return false; // Remove square when it goes out of bounds
                }
                
                return true;
            }

            shouldBranch(mouseX, mouseY, isClicked = false) {
                if (this.generation >= 2) return false;
                
                // Only branch when clicked, not on proximity
                if (!isClicked) return false;
                
                // Don't branch if near boundaries to prevent edge multiplication
                const padding = 150;
                const isNearBoundary = this.x < padding || 
                                       this.x > window.innerWidth - padding || 
                                       this.y < padding || 
                                       this.y > window.innerHeight - padding;
                
                if (isNearBoundary) return false;
                
                // Check if click is near this square
                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                return dist < 50; // Only branch if click is close to this square
            }

            branch() {
                const branches = [];
                const numBranches = 2 + Math.floor(Math.random() * 2);
                
                for (let i = 0; i < numBranches; i++) {
                    const angle = (Math.PI * 2 * i / numBranches) + (Math.random() - 0.5) * 0.5;
                    const speed = this.speed * (0.8 + Math.random() * 0.4);
                    const newSize = this.size * 0.6;
                    const colors = [
                        'linear-gradient(45deg, #ff6b6b, #ee5a24)',
                        'linear-gradient(45deg, #4834d4, #686de0)',
                        'linear-gradient(45deg, #00d2d3, #54a0ff)',
                        'linear-gradient(45deg, #5f27cd, #00d2d3)',
                        'linear-gradient(45deg, #ff9ff3, #f368e0)'
                    ];
                    
                    const branch = new ThoughtSquare(
                        this.x + Math.cos(angle) * 20,
                        this.y + Math.sin(angle) * 20,
                        newSize,
                        colors[Math.floor(Math.random() * colors.length)],
                        speed,
                        this.generation + 1
                    );
                    
                    branch.vx = this.vx + Math.cos(angle) * 0.5;
                    branch.vy = this.vy + Math.sin(angle) * 0.5;
                    
                    branches.push(branch);
                }
                
                return branches;
            }

            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 200;
                this.strength = 1;
                this.life = 1;
                this.element = this.createElement();
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'ripple';
                el.style.left = (this.x - 200) + 'px';
                el.style.top = (this.y - 200) + 'px';
                container.appendChild(el);
                return el;
            }

            update() {
                this.radius += 3;
                this.life = Math.max(0, 1 - this.radius / this.maxRadius);
                this.strength = this.life;

                if (this.life <= 0) {
                    this.destroy();
                    return false;
                }
                return true;
            }

            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }

        let container;
        let cursor;
        const squares = [];
        const ripples = [];
        let mouseX = 0, mouseY = 0;
        let animationId;
        let lastMouseMove = 0;
        let isHovering = false;
        let lastClickX = 0, lastClickY = 0;
        let isClickFrame = false;

        function initializeAnimation() {
            container = document.getElementById('thought-flow-container');
            cursor = document.getElementById('custom-cursor');
            
            if (!container) {
                console.error("❌ Container not found, retrying...");
                setTimeout(initializeAnimation, 100);
                return;
            }
            
            console.log("✨ Container found, starting animation");
            
            // Mouse tracking
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                lastMouseMove = Date.now();
                isHovering = true;
                
                if (cursor) {
                    cursor.style.left = (mouseX - 10) + 'px';
                    cursor.style.top = (mouseY - 10) + 'px';
                    cursor.classList.remove('hidden');
                }
            });

            // Detect when mouse stops moving (not hovering)
            setInterval(() => {
                if (Date.now() - lastMouseMove > 2000) { // 2 seconds of no movement
                    isHovering = false;
                }
            }, 500);

            // Click for ripples and square explosion
            document.addEventListener('click', (e) => {
                lastClickX = e.clientX;
                lastClickY = e.clientY;
                isClickFrame = true;
                
                // Create ripples
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        ripples.push(new Ripple(e.clientX + (Math.random() - 0.5) * 50, e.clientY + (Math.random() - 0.5) * 50));
                    }, i * 100);
                }
            });

            // Start animation
            animate();
            
            // Initial squares
            for (let i = 0; i < 2; i++) {
                setTimeout(() => spawnSquare(), i * 1200);
            }
        }

        function spawnSquare() {
            const colors = [
                'linear-gradient(45deg, #667eea, #764ba2)',
                'linear-gradient(45deg, #f093fb, #f5576c)',
                'linear-gradient(45deg, #4facfe, #00f2fe)',
                'linear-gradient(45deg, #43e97b, #38f9d7)',
                'linear-gradient(45deg, #fa709a, #fee140)'
            ];

            const size = 20 + Math.random() * 20; // Slightly smaller for duckling feel
            const x = window.innerWidth + 50; // Start from right side
            const y = window.innerHeight * 0.3 + (Math.random() - 0.5) * 200; // Middle area with some variation
            const speed = 0.8 + Math.random() * 0.4; // Moderate speed
            
            squares.push(new ThoughtSquare(
                x,
                y,
                size,
                colors[Math.floor(Math.random() * colors.length)],
                speed,
                0
            ));
        }

        function spawnSquareNearMouse() {
            const colors = [
                'linear-gradient(45deg, #667eea, #764ba2)',
                'linear-gradient(45deg, #f093fb, #f5576c)',
                'linear-gradient(45deg, #4facfe, #00f2fe)',
                'linear-gradient(45deg, #43e97b, #38f9d7)',
                'linear-gradient(45deg, #fa709a, #fee140)'
            ];

            const size = 18 + Math.random() * 22;
            
            // Spawn from right side, but at a similar Y level to mouse
            const x = window.innerWidth + 50;
            const y = mouseY + (Math.random() - 0.5) * 100; // Near mouse Y level
            
            const speed = 0.6 + Math.random() * 0.4;
            
            squares.push(new ThoughtSquare(
                x,
                y,
                size,
                colors[Math.floor(Math.random() * colors.length)],
                speed,
                0
            ));
        }

        function animate() {
            if (!container) return;
            
            // Update squares
            for (let i = squares.length - 1; i >= 0; i--) {
                const square = squares[i];
                
                // Check for branching on click
                if (isClickFrame && square.shouldBranch(lastClickX, lastClickY, true)) {
                    const branches = square.branch();
                    squares.push(...branches);
                }
                
                // Update square
                if (!square.update(mouseX, mouseY)) {
                    square.destroy();
                    squares.splice(i, 1);
                }
            }

            // Reset click frame flag
            isClickFrame = false;

            // Spawn new squares - much more conservative rates
            let spawnRate;
            if (isHovering) {
                spawnRate = 0.008; // Slightly increased for duckling parade
            } else {
                spawnRate = 0.003; // Regular duckling spawning
            }
            
            if (Math.random() < spawnRate) {
                // Limit total number of squares to prevent overcrowding
                if (squares.length < 6) { // Reduced for duckling formation
                    // When hovering, spawn some squares near the mouse cursor
                    if (isHovering && Math.random() < 0.5) {
                        spawnSquareNearMouse();
                    } else {
                        spawnSquare();
                    }
                }
            }

            animationId = requestAnimationFrame(animate);
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeAnimation);
        } else {
            setTimeout(initializeAnimation, 100);
        }

        console.log("✨ Thought Flow Squares script loaded");
    })();
</script>